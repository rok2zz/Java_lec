package Chap06_07.EX03;

// 기본 생성자 : class A 는 기본 생성자가 생략되어 있다. 
// 일반적으로 클래스 블락에 1. 필드, 2. 생성자, 3. 메소드 형식으로 작성한다. 
// 생성자의 역활 : 1. 객체 생성, 2. 필드의 값을 초기화 

class A{
    int m; 			//필드(클래스 블락에 선언된 변수 ) :     데이터타입  변수명 
					   // 힙 영역에 저장 , 객체화 시켜야 사용 가능, 예외) static , 
    					// 힙 영역의 RAM 에는 반드시 초기값이 들어가야 한다. 
    
  //  A () { } 		// <== 생성자 : 클래스 이름과 동일하면서 리턴타입이 없는 메소드를 생성자라 호칭 한다. 
    				// 기본 생성자는 생략 가능 하다. 
    				// 기본 생성자는 매개변수도 없고, 실행부도 가지지 않는 생성자 
    
	void work() {	//메소드 :     리턴타입 메소드명 (인풋 매개변수 ) {  실행부  } 
					    // 메소드 호출 : work()  
		System.out.println(m); //0       //m : 메모리의 값을 가지고 온다. 
	}
	
	
}
class B {
	int m ; 		// m 은 Heap 영역에 저장이 되고, 기본 값으로  0 을 출력 
	
	B () {} 	//기본 생성자 는 생략 가능하다. 객체의 필드의 초기값을 기본값으로 출력 
	
	void work() {
		System.out.println(m);  // 0   메모리의 초기값으로 0을 출력 
	}
		
}

// 객체 생성시 생성자를 통해서 필드의 초기값을 할당하고 객체 생성 , 

class C {			//
	int m ; 
	
	//  C() { } 	// 기본 생성자는 생략됨 , 다른 생성자가 존재하는 경우 외부에서 기본 생성자 호출시 
					//  기본 생성자는 생략되면 안된다. 
	
	C (int c){		// 생성자의 인풋 값을 받아서 메모리의 기본값으로 m변수 값을 오드 시킨다. 
		m = c ; 
	}
	
	void work () {
		System.out.println(m);    //m은 객체 생성시 생성자에 정수 값을 넣어서 필드 m을 초기화 시켜줌 
	}
	
}

class D {
	int m , n , l ;
	
	D () {} 					//기본 생성쟈 
	D (int m, int n) {		// 매개변수 2개 
		this.m = m;			// this :  자기 자신의 객체, 지역변수가 아니라 필드의 변수를 알려줌 
		this.n = n;			
	}
	D (int a, int b, int c){    //매개 변수가 3개인 생성자 
		m = a; 
		n = b; 
		l = c; 
	}
	
	void work () {		//work()를 호출시 각각의 메모리의 값을 출력 
		System.out.println("m : " + m + ", n : " + n + ", l : " + l);
	}
	
}

public class DefaultConstructor {

	public static void main(String[] args) {
		//클래스 내에 포함 될수 있는 것 : 1. 필드, 2. 메소드 , 3. 생성자, 4.인어 클래스(innerClass) 
		//생성자의 2가지 특징 : 1. 클래스 이름과 동일한 이름을 가진 메소드를 생성자라 한다. 
					//		2. 생성자는 반환 타입이 없다. (메소드는 반환타입이 있다.) 
		//생성자를 사용하는 이유 : 객체를 생성할때 필드의 값을 초기화 하면서 객체를 생설하고자 할때 사용. 
			//클래스 내에서 필드의 초기 값은 일반적으로 할당하지 않는다. 
			//클래스의 객체를 생성할때 초기값을 할당하면서 객체를 생성할때 
		
		//객체를 생성할때, 반드시 생성자를 호출 ,       A a  = new A();       <==객체 생성 구문 
		
		// 기본 생성자 ( Default Constructor ) : 
			// 인풋 매개변수가 없는 생성자, 실행부의 값도 비어있는 상태의 생성자. 
			// 기본 생성자는 생략 가능 하다. 
			// 생략되어 있을 경우 , 컴파일러가 자동으로 생성해서 컴파일. 
			// 클래스 내의 기본 생성자 이외의 다른 생성자가 존재하는 경우, 기본 생성자 호출시 생략되면 안된다. 
			
			A a = new A(); 		// A(); : 기본 생성자 호출 , <<< 생성자 생략됨 >>>, 컴파일러가 기본 생성자를 할당 
								// 객체 생성시 반드시 생성자를 호출 해야 한다.
	        a.work();  // 0 
			

	        B b = new B() ; // <<<기본 생성자 호출>>>  	        
	        b.work();	//0        <== 객체의 초기값 출력 : 
	        
	        C c = new C(3) ; 	//<<<생성자 호출시 기본값을 인풋해서 메모리 필드에 초기값 구성>>>
	        c.work();			// 객체 생성시 기본 기능 : 객체 생성과 + 필드의 값을 초기화 
	        
	        C cc = new C(5); 
	        cc.work(); 
	        
	        C ccc = new C(10); 
	        ccc.work();
	        
	        // class C는 기본 생성자가 생략 되어 있다.  // C() {}  
	        // class C는 인풋 매개 변수가 하나인 생성자가 존재 
	        
	      //  C cccc new C();		//오류 발생 : 기본생성자가 생략, 다른 생성자가 존재 , <<기본생성자 호출>>
	        
	        D d = new D(); 	//기본 생성자 호출, 객체의 필드의 초기값 (m:0,n:0,l:0) 
	        d.work();       // 
	        
	        D dd = new D(3,4,5); 	// 매개변수가 정수  3개인 생성자 호출 
	        dd.work();
	        
	        D ddd = new D( 1, 2) ; 	// 매개변수가 정수 3개인 생성자를 호출
	        ddd.work();
	        
	        // 생성자 : 메소드 이름이 객체이름과 리턴값이 없는 메소드 
	        // 객체 내의 필드의 값을 초기화 할때 오버로딩 (Overloading ) 에의 해서 해당 생성자가 호출 
	        	//오버로딩 : 메소드명(생성자명, 데이터 타입, 매개변수 갯수) < == 시그니쳐 
	        		//오류가발생 되는 경우 : 동일한 데이터 타입 과 갯수가 동일한 경우 ,
	        
	}

}
